# Cassandra storage config YAML 

# NOTE:
#   See http://wiki.apache.org/cassandra/StorageConfiguration for
#   full explanations of configuration directives
# /NOTE

# The name of the cluster. This is mainly used to prevent machines in
# one logical cluster from joining another.
cluster_name:  '<%= @cassandra[:cluster_name] %>'

# This defines the number of tokens randomly assigned to this node on the ring
# The more tokens, relative to other nodes, the larger the proportion of data
# that this node will store. You probably want all nodes to have the same number
# of tokens assuming they have equal hardware capability.
#
# If you leave this unspecified, Cassandra will use the default of 1 token for legacy compatibility,
# and will use the initial_token as described below.
#
# Specifying initial_token will override this setting.
#
# If you already have a cluster with 1 token per node, and wish to migrate to
# multiple tokens per node, see http://wiki.apache.org/cassandra/Operations
num_tokens: <%= @cassandra[:num_tokens] %>

# If you haven't specified num_tokens, or have set it to the default of 1 then
# you should always specify InitialToken when setting up a production
# cluster for the first time, and often when adding capacity later.
# The principle is that each node should be given an equal slice of
# the token ring; see http://wiki.apache.org/cassandra/Operations
# for more details.
#
# If blank, Cassandra will request a token bisecting the range of
# the heaviest-loaded existing node.  If there is no load information
# available, such as is the case with a new cluster, it will pick
# a random token, which will lead to hot spots.
initial_token: <%= @cassandra[:initial_token] %> # blank

# See http://wiki.apache.org/cassandra/HintedHandoff
hinted_handoff_enabled: <%= @cassandra[:hinted_handoff_enabled] %> #true
# this defines the maximum amount of time a dead host will have hints
# generated.  After it has been dead this long, hints will be dropped.
max_hint_window_in_ms: <%= @cassandra[:max_hint_window_in_ms] %> # three hours
# throttle in KB's per second, per delivery thread
hinted_handoff_throttle_in_kb: 1024

# The following setting populates the page cache on memtable flush and compaction
# WARNING: Enable this setting only when the whole node's data fits in memory.
# Defaults to: false
populate_io_cache_on_flush: <%= @cassandra[:populate_io_cache_on_flush] %>

# authentication backend, implementing IAuthenticator; used to identify users
authenticator: <%= @cassandra[:authenticator] %>  #org.apache.cassandra.auth.AllowAllAuthenticator

# authorization backend, implementing IAuthority; used to limit access/provide permissions
authorizer: <%= @cassandra[:authorizer] %>  #org.apache.cassandra.auth.AllowAllAuthority

# Validity period for permissions cache (fetching permissions can be an
# expensive operation depending on the authorizer, CassandraAuthorizer is
# one example). Defaults to 2000, set to 0 to disable.
# Will be disabled automatically for AllowAllAuthorizer.
permissions_validity_in_ms: <%= @cassandra[:permissions_validity_in_ms] %>

# The partitioner is responsible for distributing rows (by key) across
# nodes in the cluster.  Any IPartitioner may be used, including your
# own as long as it is on the classpath.  Out of the box, Cassandra
# provides org.apache.cassandra.dht.{Murmur3Partitioner, RandomPartitioner
# ByteOrderedPartitioner, OrderPreservingPartitioner (deprecated)}.
#
# - RandomPartitioner distributes rows across the cluster evenly by md5.
#   This is the default prior to 1.2 and is retained for compatibility.
# - Murmur3Partitioner is similar to RandomPartioner but uses Murmur3_128
#   Hash Function instead of md5.  When in doubt, this is the best option.
# - ByteOrderedPartitioner orders rows lexically by key bytes.  BOP allows
#   scanning rows in key order, but the ordering can generate hot spots
#   for sequential insertion workloads.
# - OrderPreservingPartitioner is an obsolete form of BOP, that stores
# - keys in a less-efficient format and only works with keys that are
#   UTF8-encoded Strings.
# - CollatingOPP colates according to EN,US rules rather than lexical byte
#   ordering.  Use this as an example if you need custom collation.
#
# See http://wiki.apache.org/cassandra/Operations for more on
# partitioners and token selection.
partitioner: <%= @cassandra[:partitioner] %>

# directories where Cassandra should store data on disk.
data_file_directories:
<%- @cassandra[:data_dirs].each do |data_file_dir| -%>
    - <%= data_file_dir %>
<%- end -%>
    #- /var/lib/cassandra/data

# commit log
commitlog_directory: <%= @cassandra[:commitlog_dir] %> #/var/lib/cassandra/commitlog

# policy for data disk failures:
# stop: shut down gossip and Thrift, leaving the node effectively dead, but
#       still inspectable via JMX.
# best_effort: stop using the failed disk and respond to requests based on
#              remaining available sstables.  This means you WILL see obsolete
#              data at CL.ONE!
# ignore: ignore fatal errors and let requests fail, as in pre-1.2 Cassandra
disk_failure_policy: <%= @cassandra[:disk_failure_policy] %>


# Maximum size of the key cache in memory.
#
# Each key cache hit saves 1 seek and each row cache hit saves 2 seeks at the
# minimum, sometimes more. The key cache is fairly tiny for the amount of
# time it saves, so it's worthwhile to use it at large numbers.
# The row cache saves even more time, but must store the whole values of
# its rows, so it is extremely space-intensive. It's best to only use the
# row cache if you have hot rows or static rows.
#
# NOTE: if you reduce the size, you may not get you hottest keys loaded on startup.
#
# Default value is empty to make it "auto" (min(5% of Heap (in MB), 100MB)). Set to 0 to disable key cache.
key_cache_size_in_mb: <%= @cassandra[:key_cache_size_in_mb] %>

# Duration in seconds after which Cassandra should
# safe the keys cache. Caches are saved to saved_caches_directory as
# specified in this configuration file.
#
# Saved caches greatly improve cold-start speeds, and is relatively cheap in
# terms of I/O for the key cache. Row cache saving is much more expensive and
# has limited use.
#
# Default is 14400 or 4 hours.
key_cache_save_period: <%= @cassandra[:key_cache_save_period] %>

# Number of keys from the key cache to save
# Disabled by default, meaning all keys are going to be saved
key_cache_keys_to_save: <%= @cassandra[:key_cache_keys_to_save] %>

# Maximum size of the row cache in memory.
# NOTE: if you reduce the size, you may not get you hottest keys loaded on startup.
#
# Default value is 0, to disable row caching.
row_cache_size_in_mb: <%= @cassandra[:row_cache_size_in_mb] %>

# Duration in seconds after which Cassandra should
# safe the row cache. Caches are saved to saved_caches_directory as specified
# in this configuration file.
#
# Saved caches greatly improve cold-start speeds, and is relatively cheap in
# terms of I/O for the key cache. Row cache saving is much more expensive and
# has limited use.
#
# Default is 0 to disable saving the row cache.
row_cache_save_period: <%= @cassandra[:row_cache_save_period] %>

# Number of keys from the row cache to save
# Disabled by default, meaning all keys are going to be saved
row_cache_keys_to_save: <%= @cassandra[:row_cache_keys_to_save] %>

# The provider for the row cache to use.
#
# Supported values are: ConcurrentLinkedHashCacheProvider, SerializingCacheProvider
#
# SerializingCacheProvider serialises the contents of the row and stores
# it in native memory, i.e., off the JVM Heap. Serialized rows take
# significantly less memory than "live" rows in the JVM, so you can cache
# more rows in a given memory footprint.  And storing the cache off-heap
# means you can use smaller heap sizes, reducing the impact of GC pauses.
#
# It is also valid to specify the fully-qualified class name to a class
# that implements org.apache.cassandra.cache.IRowCacheProvider.
#
# Defaults to SerializingCacheProvider
row_cache_provider: <%= @cassandra[:row_cache_provider] %>

# saved caches
saved_caches_directory: <%= @cassandra[:saved_caches_dir] %> #/var/lib/cassandra/saved_caches

# commitlog_sync supports the following modes:
# 
# batch:
# In batch mode, Cassandra won't ack writes until the commit log
# has been fsynced to disk.  But fsyncing each write at once is
# performance-prohibitive, so instead Cassandra will wait up to
# commitlog_sync_batch_window_in_ms milliseconds for other writes, before
# syncing that "batch" at once.  This causes a performance penalty
# of about 15% when the commitlog is on a separate device, and much more
# when it shares the same device as the data files.
#
# periodic:
# Writes may be acked immediately (without waiting for the commitlog
# append) and the CommitLog is simply synced every
# commitlog_sync_period_in_ms milliseconds.
#
# periodic_without_flush:
# Like periodic, but the commitlog write buffer is only flushed
# before the sync, so any interruption to the process can be
# expected to lose some writes.  This is the old 0.6 periodic
# behavior and will be removed in future versions if testing
# continues to show no performance benefit over normal periodic.
commitlog_sync: <%= @cassandra[:commitlog_sync] %> #periodic
commitlog_sync_period_in_ms: <%= @cassandra[:commitlog_sync_period] %> #10000
# commitlog_sync: batch
# commitlog_sync_batch_window_in_ms: 10

# The size of the individual commitlog file segments.  A commitlog
# segment may be archived, deleted, or recycled once all the data
# in it (potentally from each columnfamily in the system) has been
# flushed to sstables.
#
# The default size is 32, which is almost always fine, but if you are
# archiving commitlog segments (see commitlog_archiving.properties),
# then you probably want a finer granularity of archiving; 8 or 16 MB
# is reasonable.
commitlog_segment_size_in_mb: <% @cassandra[:commitlog_segment_size_in_mb] %>

# emergency pressure valve: each time heap usage after a full (CMS)
# garbage collection is above this fraction of the max, Cassandra will
# flush the largest memtables.  
#
# Set to 1.0 to disable.  Setting this lower than
# CMSInitiatingOccupancyFraction is not likely to be useful.
#
# RELYING ON THIS AS YOUR PRIMARY TUNING MECHANISM WILL WORK POORLY:
# it is most effective under light to moderate load, or read-heavy
# workloads; under truly massive write load, it will often be too
# little, too late.
flush_largest_memtables_at: <%= @cassandra[:flush_largest_memtables_at] %> # 0.75

# emergency pressure valve #2: the first time heap usage after a full
# (CMS) garbage collection is above this fraction of the max,
# Cassandra will reduce cache maximum _capacity_ to the given fraction
# of the current _size_.  Should usually be set substantially above
# flush_largest_memtables_at, since that will have less long-term
# impact on the system.  
# 
# Set to 1.0 to disable.  Setting this lower than
# CMSInitiatingOccupancyFraction is not likely to be useful.
reduce_cache_sizes_at: <%= @cassandra[:reduce_cache_sizes_at] %> # 0.85
reduce_cache_capacity_to: <%= @cassandra[:reduce_cache_capacity_to] %> # 0.6

# Addresses of hosts that are deemed contact points.
# Cassandra nodes use this list of hosts to find each other and learn
# the topology of the ring.  You must change this if you are running
# multiple nodes!
seeds:
<%- @seeds.each do |seed| -%>
    - <%= seed %>
<%- end -%>

# Unlike most systems, in Cassandra writes are faster than reads, so
# you can afford more of those in parallel.  A good rule of thumb is 2
# concurrent reads per processor core.  Increase ConcurrentWrites to
# the number of clients writing at once if you enable CommitLogSync +
# CommitLogSyncDelay. -->
concurrent_reads: <%= @cassandra[ :concurrent_reads ] %> #8
concurrent_writes: <%= @cassandra[ :concurrent_writes ] %> #32

# Total memory to use for memtables.  Cassandra will flush the largest
# memtable when this much memory is used.
# If omitted, Cassandra will set it to 1/3 of the heap.
# memtable_total_space_in_mb: 2048
<%if @cassandra.has_key("memtable_total_space_in_mb") %>
memtable_total_space_in_mb: <%= @cassandra[:memtable_total_space_in_mb] %>
<% else %>
# memtable_total_space_in_mb: 2048
<% end %>

# Total space to use for commitlogs.  Since commitlog segments are
# mmapped, and hence use up address space, the default size is 32
# on 32-bit JVMs, and 1024 on 64-bit JVMs.
#
# If space gets above this value (it will round up to the next nearest
# segment multiple), Cassandra will flush every dirty CF in the oldest
# segment and remove it.  So a small total commitlog space will tend
# to cause more flush activity on less-active columnfamilies.
<%if @cassandra.has_key?("memtable_total_space_in_mb") %>
commitlog_total_space_in_mb: <%= @cassandra[:commitlog_total_space_in_mb] %>
<% else %>
# commitlog_total_space_in_mb: 4096
<% end %>

# This sets the amount of memtable flush writer threads.  These will
# be blocked by disk io, and each one will hold a memtable in memory
# while blocked. If you have a large heap and many data directories,
# you can increase this value for better flush performance.
# By default this will be set to the amount of data directories defined.
memtable_flush_writers: <%= @cassandra[:memtable_flush_writers] %> #1

# the number of full memtables to allow pending flush, that is,
# waiting for a writer thread.  At a minimum, this should be set to
# the maximum number of secondary indexes created on a single CF.
memtable_flush_queue_size: <%= @cassandra[:memtable_flush_queue_size] %>

# Whether to, when doing sequential writing, fsync() at intervals in
# order to force the operating system to flush the dirty
# buffers. Enable this to avoid sudden dirty buffer flushing from
# impacting read latencies. Almost always a good idea on SSD:s; not
# necessarily on platters.
trickle_fsync: <%= @cassandra[:trickle_fsync] %>
trickle_fsync_interval_in_kb: 10240

# TCP port, for commands and data
storage_port: <%= @cassandra[:storage_port] %> #7000

# Address to bind to and tell other Cassandra nodes to connect to. You
# _must_ change this if you want multiple nodes to be able to
# communicate!
# 
# Leaving it blank leaves it up to InetAddress.getLocalHost(). This
# will always do the Right Thing *if* the node is properly configured
# (hostname, name resolution, etc), and the Right Thing is to use the
# address associated with the hostname (it might not be).
#
# Setting this to 0.0.0.0 is always wrong.
listen_address: <%= @cassandra[:listen_addr] %> #localhost

# The address to bind the Thrift RPC service to -- clients connect
# here. Unlike ListenAddress above, you *can* specify 0.0.0.0 here if
# you want Thrift to listen on all interfaces.
# 
# Leaving this blank has the same effect it does for ListenAddress,
# (i.e. it will be based on the configured hostname of the node).
rpc_address: <%= @cassandra[:rpc_addr] %> #localhost
# port for Thrift to listen for clients on
rpc_port: <%= @cassandra[:rpc_port] %> #9160

# enable or disable keepalive on rpc connections
rpc_keepalive: <%= @cassandra[:rpc_keepalive] %> #true

# uncomment to set socket buffer sizes on rpc connections
# rpc_send_buff_size_in_bytes:
# rpc_recv_buff_size_in_bytes:

# Frame size for thrift (maximum field length).
# 0 disables TFramedTransport in favor of TSocket. This option
# is deprecated; we strongly recommend using Framed mode.
thrift_framed_transport_size_in_mb: <%= @cassandra[:thrift_framed_transport] %> #15

# The max length of a thrift message, including all fields and
# internal thrift overhead.
thrift_max_message_length_in_mb: <%= @cassandra[:thrift_max_message_length] %> #16

# Set to true to have Cassandra create a hard link to each sstable
# flushed or streamed locally in a backups/ subdirectory of the
# Keyspace data.  Removing these links is the operator's
# responsibility.
incremental_backups: <%= @cassandra[:incremental_backups] %> # false

# Whether or not to take a snapshot before each compaction.  Be
# careful using this option, since Cassandra won't clean up the
# snapshots for you.  Mostly useful if you're paranoid when there
# is a data format change.
snapshot_before_compaction: <%= @cassandra[:snapshot_before_compaction ] %> #false

# change this to increase the compaction thread's priority.  In java, 1 is the
# lowest priority and that is our default.
# compaction_thread_priority: 1

# Add column indexes to a row after its contents reach this size.
# Increase if your column values are large, or if you have a very large
# number of columns.  The competing causes are, Cassandra has to
# deserialize this much of the row to read a single column, so you want
# it to be small - at least if you do many partial-row reads - but all
# the index data is read for each access, so you don't want to generate
# that wastefully either.
column_index_size_in_kb: <%= @cassandra[:column_index_size] %> #64

# Size limit for rows being compacted in memory.  Larger rows will spill
# over to disk and use a slower two-pass compaction process.  A message
# will be logged specifying the row key.
in_memory_compaction_limit_in_mb: <%= @cassandra[:in_memory_compaction_limit] %> #64

# Track cached row keys during compaction, and re-cache their new
# positions in the compacted sstable.  Disable if you use really large
# key caches.
compaction_preheat_key_cache: <%= @cassandra[:compaction_preheat_key_cache] %> # true

# Time to wait for a reply from other nodes before failing the command 
rpc_timeout_in_ms: <%= @cassandra[:rpc_timeout_in_ms] %> #10000

# phi value that must be reached for a host to be marked down.
# most users should never need to adjust this.
phi_convict_threshold: <%= @cassandra[:phi_convict_threshold] %> #8

# endpoint_snitch -- Set this to a class that implements
# IEndpointSnitch, which will let Cassandra know enough
# about your network topology to route requests efficiently.
# Out of the box, Cassandra provides
#  - org.apache.cassandra.locator.SimpleSnitch:
#    Treats Strategy order as proximity. This improves cache locality
#    when disabling read repair, which can further improve throughput.
#  - org.apache.cassandra.locator.RackInferringSnitch:
#    Proximity is determined by rack and data center, which are
#    assumed to correspond to the 3rd and 2nd octet of each node's
#    IP address, respectively
# org.apache.cassandra.locator.PropertyFileSnitch:
#  - Proximity is determined by rack and data center, which are
#    explicitly configured in cassandra-topology.properties.
endpoint_snitch: <%= @cassandra[:endpoint_snitch] %> #org.apache.cassandra.locator.SimpleSnitch

# dynamic_snitch -- This boolean controls whether the above snitch is
# wrapped with a dynamic snitch, which will monitor read latencies
# and avoid reading from hosts that have slowed (due to compaction,
# for instance)
dynamic_snitch: <%= @cassandra[:dynamic_snitch ] %> #true
# controls how often to perform the more expensive part of host score
# calculation
dynamic_snitch_update_interval_in_ms: 100 
# controls how often to reset all host scores, allowing a bad host to
# possibly recover
dynamic_snitch_reset_interval_in_ms: 600000
# if set greater than zero and read_repair_chance is < 1.0, this will allow
# 'pinning' of replicas to hosts in order to increase cache capacity.
# The badness threshold will control how much worse the pinned host has to be
# before the dynamic snitch will prefer other replicas over it.  This is
# expressed as a double which represents a percentage.  Thus, a value of
# 0.2 means Cassandra would continue to prefer the static snitch values
# until the pinned host was 20% worse than the fastest.
dynamic_snitch_badness_threshold: 0.0

# request_scheduler -- Set this to a class that implements
# RequestScheduler, which will schedule incoming client requests
# according to the specific policy. This is useful for multi-tenancy
# with a single Cassandra cluster.
# NOTE: This is specifically for requests from the client and does
# not affect inter node communication.
# org.apache.cassandra.scheduler.NoScheduler - No scheduling takes place
# org.apache.cassandra.scheduler.RoundRobinScheduler - Round robin of
# client requests to a node with a separate queue for each
# request_scheduler_id. The scheduler is further customized by
# request_scheduler_options as described below.
request_scheduler: <%= @cassandra[:request_scheduler] %> #org.apache.cassandra.scheduler.NoScheduler

# Scheduler Options vary based on the type of scheduler
# NoScheduler - Has no options
# RoundRobin
#  - throttle_limit -- The throttle_limit is the number of in-flight
#                      requests per client.  Requests beyond 
#                      that limit are queued up until
#                      running requests can complete.
#                      The value of 80 here is twice the number of
#                      concurrent_reads + concurrent_writes.
#  - default_weight -- default_weight is optional and allows for
#                      overriding the default which is 1.
#  - weights -- Weights are optional and will default to 1 or the
#               overridden default_weight. The weight translates into how
#               many requests are handled during each turn of the
#               RoundRobin, based on the scheduler id.
#
# request_scheduler_options:
#    throttle_limit: 80
#    default_weight: 5
#    weights:
#      Keyspace1: 1
#      Keyspace2: 5

# request_scheduler_id -- An identifer based on which to perform
# the request scheduling. Currently the only valid option is keyspace.
# request_scheduler_id: keyspace

# The Index Interval determines how large the sampling of row keys
#  is for a given SSTable. The larger the sampling, the more effective
#  the index is at the cost of space.
index_interval: 128
