// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var Backbone, DataStore, RelationalModel, _;
    Backbone = require('backbone');
    _ = require('underscore');
    DataStore = (function() {

      function DataStore() {
        this.map = {};
      }

      DataStore.prototype.set = function(attributeName, instance) {
        this.map[attributeName] = instance;
        return instance;
      };

      DataStore.prototype.get = function(attributeName) {
        return this.map[attributeName];
      };

      DataStore.prototype.unset = function(attributeName) {
        return delete this.map[attributeName];
      };

      return DataStore;

    })();
    RelationalModel = (function(_super) {

      __extends(RelationalModel, _super);

      function RelationalModel(attributes, options) {
        this.dataStore = new DataStore();
        Backbone.Model.call(this, attributes, options);
      }

      RelationalModel.prototype.relations = {};

      RelationalModel.prototype.set = function(key, value, options) {
        var AugmentedClass, Class, attr, attrs, changes, config, escaped, keyName, now, prev, relation, relationData, relationOptions, type, updateOptions, val, _ref;
        if (_.isObject(key) || !(key != null)) {
          attrs = key;
          options = value;
        } else {
          attrs = {};
          attrs[key] = value;
        }
        options || (options = {});
        if (!attrs) {
          return this;
        }
        if (attrs instanceof Backbone.Model) {
          attrs = attrs.attributes;
        }
        if (options.unset) {
          for (attr in attrs) {
            attrs[attr] = void 0;
          }
        }
        if (!this._validate(attrs, options)) {
          return false;
        }
        if (this.idAttribute in attrs) {
          this.id = attrs[this.idAttribute];
        }
        changes = options.changes = {};
        now = this.attributes;
        escaped = this._escapedAttributes;
        prev = this._previousAttributes || {};
        for (attr in attrs) {
          val = attrs[attr];
          if (!_.isEqual(now[attr], val) || (options.unset && _.has(now, attr))) {
            delete escaped[attr];
            (options.silent ? this._silent : changes)[attr] = true;
          }
          if (options.unset) {
            delete now[attr];
          } else {
            now[attr] = val;
          }
          if (!_.isEqual(prev[attr], val) || (_.has(now, attr) !== _.has(prev, attr))) {
            this.changed[attr] = val;
            if (!options.silent) {
              this._pending[attr] = true;
            }
          } else {
            delete this.changed[attr];
            delete this._pending[attr];
          }
          if (options.skipRelations != null) {
            continue;
          }
          _ref = this.relations;
          for (keyName in _ref) {
            config = _ref[keyName];
            if (keyName !== attr) {
              continue;
            }
            Class = config.Class, relationOptions = config.relationOptions, type = config.type;
            relation = this.dataStore.get(keyName);
            relationData = now[attr];
            if (!(relation != null)) {
              if (options.unset) {
                continue;
              }
              relationOptions = _.extend({}, relationOptions, {
                parse: true,
                parent: this
              });
              AugmentedClass = this._augmentClass(Class);
              if (type === 'collection') {
                relation = this.dataStore.set(keyName, new AugmentedClass([], relationOptions));
                relation.reset(relation.parse(relationData), {
                  silent: true,
                  parse: true
                });
              } else {
                relation = this.dataStore.set(keyName, new AugmentedClass(relationData, relationOptions));
              }
              this._setupEventBubbling(relation, keyName, type);
            } else {
              if (options.unset) {
                relation.off(null, null, this);
                this.dataStore.unset(keyName);
                continue;
              }
              updateOptions = {
                parse: true,
                silent: options.silent
              };
              relation.off(null, null, this);
              if (type === 'collection') {
                relation.reset(relation.parse(relationData), updateOptions);
              } else {
                relation.clear({
                  silent: true
                }).set(relationData, updateOptions);
              }
              this._setupEventBubbling(relation, keyName, type);
            }
          }
        }
        if (!options.silent) {
          this.change(options);
        }
        return this;
      };

      RelationalModel.prototype._augmentClass = function(TheClass) {
        var AugmentedClass, instance;
        instance = this;
        AugmentedClass = (function(_super1) {

          __extends(AugmentedClass, _super1);

          function AugmentedClass() {
            this.parent = instance;
            AugmentedClass.__super__.constructor.apply(this, arguments);
          }

          AugmentedClass.prototype.root = function() {
            var root;
            root = this.parent;
            while (root.parent != null) {
              root = root.parent;
            }
            return root;
          };

          return AugmentedClass;

        })(TheClass);
        return AugmentedClass;
      };

      RelationalModel.prototype._setupEventBubbling = function(relation, keyName, type) {
        var getCollectionData;
        getCollectionData = function() {
          return (relation.unParse || relation.toJSON).call(relation);
        };
        return relation.on('all', function(event, model, options) {
          var bubbleOptions, data;
          bubbleOptions = {
            skipRelations: true
          };
          switch (event) {
            case 'change':
              data = type === 'collection' ? getCollectionData() : model.toJSON();
              return this.set(keyName, data, bubbleOptions);
            case 'destroy':
              if (type === 'collection') {
                return this.set(keyName, getCollectionData(), bubbleOptions);
              } else {
                this.unset(keyName, bubbleOptions);
                this.dataStore.unset(keyName);
                return relation.off(null, null, this);
              }
              break;
            case 'remove':
            case 'add':
            case 'reset':
              return this.set(keyName, getCollectionData(), bubbleOptions);
          }
        }, this);
      };

      return RelationalModel;

    })(Backbone.Model);
    return {
      RelationalModel: RelationalModel
    };
  });

}).call(this);
