// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var Backbone, BaseModel, Blob, Bucket, Commits, Data, Index, IndexQuery, NodesCollection, Ref, Refs, RelationalModel, Schedule, TYPE_FOLDER, base, ref, _fn, _i, _len, _ref;
    TYPE_FOLDER = require('src/const').TYPE_FOLDER;
    base = require('src/base');
    BaseModel = require('src/browse/base').BaseModel;
    RelationalModel = require('src/relational_model').RelationalModel;
    Backbone = require('backbone');
    IndexQuery = (function(_super) {

      __extends(IndexQuery, _super);

      function IndexQuery() {
        return IndexQuery.__super__.constructor.apply(this, arguments);
      }

      IndexQuery.prototype.url = "" + window.API_PREFIX + "/";

      IndexQuery.prototype.defaults = {
        q: '.',
        limit: 0
      };

      IndexQuery.folderFirstComparator = function(a, b) {
        var isAFolder, isBFolder, sorted;
        isAFolder = a.get('data_type') === TYPE_FOLDER;
        isBFolder = b.get('data_type') === TYPE_FOLDER;
        if (isAFolder && !isBFolder) {
          return -1;
        }
        if (isBFolder && !isAFolder) {
          return 1;
        }
        if ((isAFolder && isBFolder) || !(isAFolder && isBFolder)) {
          sorted = [a.get('_id'), b.get('_id')].sort();
          if (sorted[0] === a.get('_id')) {
            return -1;
          } else {
            return 1;
          }
        }
        return 0;
      };

      IndexQuery.prototype.byType = function(query, types) {
        return this.fetch({
          data: {
            q: query,
            only: types.join(',')
          }
        });
      };

      IndexQuery.prototype.notByType = function(query, types) {
        return this.fetch({
          data: {
            q: query,
            not: types.join(',')
          }
        });
      };

      IndexQuery.prototype.fetch = function(options) {
        options || (options = {});
        options.data = _.extend({}, this.defaults, options.data || (options.data = {}));
        return IndexQuery.__super__.fetch.call(this, options);
      };

      return IndexQuery;

    })(base.Collection);
    NodesCollection = (function(_super) {

      __extends(NodesCollection, _super);

      function NodesCollection() {
        return NodesCollection.__super__.constructor.apply(this, arguments);
      }

      NodesCollection.prototype.url = "" + window.API_PREFIX + "/";

      NodesCollection.prototype.fetch = function(options) {
        var _base, _base1, _ref;
        options = options != null ? _.clone(options) : {};
        options.data || (options.data = {});
        (_base = options.data).q || (_base.q = '.');
        if ((_ref = (_base1 = options.data).limit) == null) {
          _base1.limit = 0;
        }
        options.data.not = 'folder';
        return NodesCollection.__super__.fetch.call(this, options);
      };

      NodesCollection.prototype.parse = function(response) {
        var item, resp, _i, _len, _results;
        resp = NodesCollection.__super__.parse.call(this, response);
        _results = [];
        for (_i = 0, _len = resp.length; _i < _len; _i++) {
          item = resp[_i];
          if (item._id != null) {
            _results.push(item);
          }
        }
        return _results;
      };

      return NodesCollection;

    })(base.Collection);
    Data = (function(_super) {

      __extends(Data, _super);

      function Data() {
        return Data.__super__.constructor.apply(this, arguments);
      }

      Data.prototype.initialize = function(attributes, _arg) {
        this.parent = _arg.parent;
      };

      Data.prototype.commitId = function() {
        return this.parent.get('commit')._id;
      };

      Data.prototype.resourceId = function() {
        return this.parent.get('index')._id;
      };

      Data.prototype.typeId = function() {
        return this.parent.get('index').data_type;
      };

      Data.prototype.save = function() {
        throw new Error('Cannot save data model');
      };

      return Data;

    })(Backbone.Model);
    Schedule = (function(_super) {

      __extends(Schedule, _super);

      function Schedule() {
        return Schedule.__super__.constructor.apply(this, arguments);
      }

      Schedule.prototype.defaults = function() {
        return {
          schedule: []
        };
      };

      Schedule.prototype.initialize = function(attributes, options) {
        Schedule.__super__.initialize.call(this);
        this.resourceId = options.resourceId;
        this.on('change:schedule', this.updateSchedulesMap, this);
        this.on('change:schedule', this.updateColorMap, this);
        if ((attributes != null ? attributes.schedule : void 0) != null) {
          this.updateSchedulesMap();
          return this.updateColorMap();
        }
      };

      Schedule.prototype.url = function() {
        return "" + window.API_PREFIX + "/" + this.resourceId + "/schedule";
      };

      Schedule.prototype.isNew = function() {
        return false;
      };

      Schedule.prototype.getActiveCount = function(timestamp) {
        return this.getActiveRefs(timestamp).length;
      };

      Schedule.prototype.getActiveRefs = function(timestamp) {
        var key, refs, times, value, _i, _len, _ref;
        refs = [];
        _ref = this.refSchedulesMap;
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          times = _ref[key].times;
          for (_i = 0, _len = times.length; _i < _len; _i++) {
            value = times[_i];
            if (value.time <= timestamp) {
              if (value.state === 'on') {
                refs.push(key);
              }
              break;
            }
          }
        }
        return refs;
      };

      Schedule.prototype.updateSchedulesMap = function() {
        var commit, ref, refSchedule, time, _base, _i, _len, _ref, _ref1, _ref2, _results;
        this.refSchedulesMap = {};
        _ref = this.get('schedule');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], commit = _ref1.commit, ref = _ref1.ref, time = _ref1.time;
          refSchedule = ((_ref2 = (_base = this.refSchedulesMap)[ref]) != null ? _ref2 : _base[ref] = {
            times: []
          });
          refSchedule.times.push({
            time: time,
            state: commit != null ? 'on' : 'off'
          });
          _results.push(refSchedule.times.sort(function(a, b) {
            return b.time - a.time;
          }));
        }
        return _results;
      };

      Schedule.prototype.updateColorMap = function() {
        var colors, index, key, _i, _len, _ref, _results;
        colors = ['blue', 'green', 'yellow', 'orange', 'purple'];
        this.refColorMap = {};
        _ref = _.keys(this.refSchedulesMap);
        _results = [];
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          key = _ref[index];
          _results.push(this.refColorMap[key] = colors[index % colors.length]);
        }
        return _results;
      };

      Schedule.prototype.validate = function(attributes) {
        var ref, _i, _len, _ref;
        _ref = attributes.schedule;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ref = _ref[_i].ref;
          if (ref.toUpperCase() === 'HEAD') {
            return 'HEAD cannot be scheduled.';
          }
        }
      };

      return Schedule;

    })(BaseModel);
    Refs = (function(_super) {

      __extends(Refs, _super);

      function Refs() {
        return Refs.__super__.constructor.apply(this, arguments);
      }

      Refs.prototype.initialize = function(models, _arg) {
        this.parent = _arg.parent;
      };

      Refs.prototype.parse = function(resp, xhr) {
        var commit, ref, _results;
        _results = [];
        for (ref in resp) {
          commit = resp[ref];
          _results.push({
            id: ref,
            commit: commit
          });
        }
        return _results;
      };

      Refs.prototype.unParse = function() {
        var model, out, _i, _len, _ref;
        out = {};
        _ref = this.toJSON();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          model = _ref[_i];
          out[model.id] = model.commit;
        }
        return out;
      };

      Refs.prototype.url = function() {
        return "" + window.API_PREFIX + "/" + (this.parent.parent.resourceId()) + "/refs";
      };

      Refs.prototype.createOrUpdate = function(attributes) {
        var model;
        if (model = this.get(attributes.id)) {
          return model.save(attributes);
        } else {
          return this.create(attributes);
        }
      };

      return Refs;

    })(Backbone.Collection);
    Index = (function(_super) {

      __extends(Index, _super);

      function Index() {
        return Index.__super__.constructor.apply(this, arguments);
      }

      Index.prototype.initialize = function(models, _arg) {
        this.parent = _arg.parent;
      };

      Index.prototype.relations = {
        refs: {
          type: 'collection',
          Class: Refs
        }
      };

      return Index;

    })(RelationalModel);
    Blob = (function(_super) {

      __extends(Blob, _super);

      function Blob() {
        return Blob.__super__.constructor.apply(this, arguments);
      }

      Blob.prototype.idAttribute = '_id';

      Blob.prototype.relations = {
        data: {
          Class: Data
        },
        index: {
          Class: Index
        }
      };

      Blob.instance = function(object, commit) {
        return new Blob({
          index: {
            _id: object
          },
          commit: {
            _id: commit
          }
        });
      };

      Blob.prototype.urlRoot = function() {
        return "" + window.API_PREFIX + "/" + (this.resourceId()) + "/commits";
      };

      Blob.prototype.initialize = function() {
        return this.id = this.get('commit')._id;
      };

      Blob.prototype.commitId = function() {
        var _ref;
        return (_ref = this.get('commit')) != null ? _ref._id : void 0;
      };

      Blob.prototype.resourceId = function() {
        return this.get('index')._id;
      };

      Blob.prototype.typeId = function() {
        return this.get('index').data_type;
      };

      Blob.prototype.schedule = function() {
        return this.get('index').schedule;
      };

      Blob.prototype.data = function() {
        return this.dataStore.get('data');
      };

      Blob.prototype.index = function() {
        return this.dataStore.get('index');
      };

      Blob.prototype.refs = function() {
        return this.get('commit').refs;
      };

      Blob.prototype.author = function() {
        return this.get('commit').author;
      };

      Blob.prototype.getFragment = function() {
        return "" + (this.get('commit').resource_id) + "/" + (this.commitId());
      };

      Blob.prototype.toJSON = function(full) {
        if (full != null) {
          return Blob.__super__.toJSON.call(this);
        }
        return this.data().toJSON();
      };

      Blob.prototype.parse = function(obj) {
        this.id = obj.commit._id;
        return obj;
      };

      return Blob;

    })(RelationalModel);
    Commits = (function(_super) {

      __extends(Commits, _super);

      function Commits() {
        return Commits.__super__.constructor.apply(this, arguments);
      }

      Commits.prototype.model = Blob;

      Commits.prototype.initialize = function() {
        return Commits.__super__.initialize.call(this);
      };

      Commits.prototype.url = function() {
        return "" + window.API_PREFIX + "/" + this.resourceId + "/commits";
      };

      Commits.prototype.refsFetch = function() {
        return this.fetch({
          data: {
            refs: 1
          }
        });
      };

      Commits.prototype.parse = function(response) {
        var commit, result, _i, _len, _results;
        result = Commits.__super__.parse.call(this, response);
        _results = [];
        for (_i = 0, _len = result.length; _i < _len; _i++) {
          commit = result[_i];
          _results.push({
            commit: commit
          });
        }
        return _results;
      };

      return Commits;

    })(base.Collection);
    Bucket = (function(_super) {

      __extends(Bucket, _super);

      function Bucket() {
        return Bucket.__super__.constructor.apply(this, arguments);
      }

      Bucket.prototype.idAttribute = '_id';

      Bucket.prototype.urlRoot = function() {
        return "" + window.API_PREFIX + "/";
      };

      return Bucket;

    })(BaseModel);
    Ref = (function(_super) {

      __extends(Ref, _super);

      function Ref() {
        return Ref.__super__.constructor.apply(this, arguments);
      }

      Ref.prototype.idAttribute = 'ref';

      Ref.prototype.urlRoot = function() {
        return "" + window.API_PREFIX + "/" + this.resourceId + "/refs/";
      };

      Ref.prototype.initialize = function(attributes, options) {
        Ref.__super__.initialize.call(this);
        return this.resourceId = options.resourceId, options;
      };

      return Ref;

    })(BaseModel);
    _ref = [Ref.prototype, Schedule.prototype, Commits.prototype];
    _fn = function(ref) {
      var oldInit;
      oldInit = ref.initialize;
      return ref.initialize = function(attributes, options) {
        if ((options != null ? options.resourceId : void 0) == null) {
          throw new Error('options.resourceId must be passed');
        }
        this.resourceId = options.resourceId;
        return oldInit.call(this, attributes, options);
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ref = _ref[_i];
      _fn(ref);
    }
    return {
      IndexQuery: IndexQuery,
      NodesCollection: NodesCollection,
      Blob: Blob,
      Commits: Commits,
      Bucket: Bucket,
      Schedule: Schedule,
      Ref: Ref,
      Data: Data,
      Index: Index
    };
  });

}).call(this);
