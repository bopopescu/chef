// Generated by CoffeeScript 1.4.0

/*
Tree View.

This module will interpret the API endpoints and render them as
a hierarchal tree view. Much like a file system browser.
*/


(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var $, Backbone, NodeView, Tree, TreeView, base, _;
    $ = require('jquery');
    _ = require('underscore');
    base = require('src/base');
    Backbone = require('backbone');
    Tree = (function(_super) {

      __extends(Tree, _super);

      function Tree() {
        return Tree.__super__.constructor.apply(this, arguments);
      }

      Tree.prototype.url = "" + window.API_PREFIX + "/";

      Tree.prototype.model = Backbone.Model;

      Tree.prototype.initialize = function(models, options) {
        this.prefix = options.prefix;
        return Tree.__super__.initialize.call(this, models, options);
      };

      Tree.prototype.fetch = function(options) {
        var _base, _ref;
        options = options != null ? _.clone(options) : {};
        options.data || (options.data = {});
        options.data.q = this.prefix || '.';
        if ((_ref = (_base = options.data).limit) == null) {
          _base.limit = 0;
        }
        options.data.only = 'folder';
        return Tree.__super__.fetch.call(this, options);
      };

      Tree.prototype.parse = function(response) {
        var item, _i, _len, _ref, _results;
        _ref = Tree.__super__.parse.call(this, response);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (!(item._id != null)) {
            continue;
          }
          item._id += '.';
          _results.push(item);
        }
        return _results;
      };

      return Tree;

    })(base.Collection);
    NodeView = (function(_super) {

      __extends(NodeView, _super);

      function NodeView() {
        return NodeView.__super__.constructor.apply(this, arguments);
      }

      /*
          It's possible to combine this into TreeView for a single nestable node
          however it makes event capturing and handling much harder.
      */


      NodeView.prototype.tagName = 'li';

      NodeView.prototype.subtree = null;

      NodeView.prototype.prefix = null;

      NodeView.prototype.attributes = {
        "class": 'node'
      };

      NodeView.prototype.events = {
        'click a': 'toggle'
      };

      NodeView.prototype.initialize = function() {
        var _ref;
        _ref = this.options, this.bus = _ref.bus, this.node = _ref.node, this.prefix = _ref.prefix;
        this.bus.on('blur', this.blur, this);
        return this.render();
      };

      NodeView.prototype.focus = function(boolSwitch) {
        if (boolSwitch == null) {
          boolSwitch = true;
        }
        return this.$el.toggleClass('focus', boolSwitch);
      };

      NodeView.prototype.blur = function() {
        return this.focus(false);
      };

      NodeView.prototype.toggle = function(e) {
        if ($(e.target).attr('href') === ("#" + (this.node.get('_id'))) && this.$el.hasClass('focus')) {
          if (this.subtree != null) {
            return this.collapse();
          } else {
            return this.expand();
          }
        }
      };

      NodeView.prototype.expand = function(to) {
        var prefix;
        prefix = this.node.get('_id');
        if (to === prefix) {
          this.focus();
        }
        if (this.subtree != null) {
          if (to != null) {
            return this.subtree.browseTo(to);
          }
        } else {
          this.subtree = new TreeView({
            prefix: prefix,
            bus: this.bus,
            openTo: to
          });
          return this.subtree.tree.on('change reset', this.render, this);
        }
      };

      NodeView.prototype.collapse = function() {
        var _ref, _ref1;
        if ((_ref = this.subtree) != null) {
          _ref.tree.off(null, null, this);
        }
        if ((_ref1 = this.subtree) != null) {
          _ref1.close();
        }
        this.subtree = null;
        return this.render();
      };

      NodeView.prototype.render = function() {
        var direction, directionClass, nodeId, state, stateClass, _ref, _ref1;
        _ref = this.subtree != null ? ['down', 'open'] : ['right', 'close'], direction = _ref[0], state = _ref[1];
        _ref1 = ["icon-caret-" + direction, "icon-folder-" + state], directionClass = _ref1[0], stateClass = _ref1[1];
        nodeId = this.node.get('_id');
        this.$el.empty().append("<i class=\"limbs " + directionClass + "\"></i>\n<a href=\"#" + nodeId + "\">\n  <i class=\"" + stateClass + "\"></i> " + (nodeId.substr(this.prefix.length)) + "\n</a>");
        if (this.subtree != null) {
          this.$el.append(this.subtree.el);
        }
        return this;
      };

      return NodeView;

    })(Backbone.View);
    TreeView = (function(_super) {

      __extends(TreeView, _super);

      function TreeView() {
        return TreeView.__super__.constructor.apply(this, arguments);
      }

      TreeView.prototype.ready = false;

      TreeView.prototype.tagName = 'ol';

      TreeView.prototype.attributes = {
        "class": 'tree'
      };

      TreeView.prototype.initialize = function() {
        var _ref, _ref1,
          _this = this;
        _ref = this.options, this.prefix = _ref.prefix, this.bus = _ref.bus, this.openTo = _ref.openTo;
        if ((_ref1 = this.bus) == null) {
          this.bus = _.clone(Backbone.Events);
        }
        this.tree = new Tree([], {
          prefix: this.prefix
        });
        this.tree.fetch();
        return this.tree.on('change reset', function() {
          var node, _i, _len, _ref2;
          _ref2 = _this.tree.models;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            node = _ref2[_i];
            node.set('nv', new NodeView({
              node: node,
              prefix: _this.prefix,
              bus: _this.bus
            }), {
              silent: true
            });
          }
          _this.ready = true;
          if (_this.openTo != null) {
            _this.browseTo(_this.openTo);
          }
          if (_this.onReadyBrowse != null) {
            _this.browseTo(_this.onReadyBrowse);
          }
          return _this.render();
        });
      };

      TreeView.prototype.browseTo = function(path) {
        var node, _i, _len, _ref;
        if (!this.ready) {
          this.onReadyBrowse = path;
          return;
        }
        _ref = this.tree.models;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (path.indexOf(node.get('_id')) === 0) {
            return node.get('nv').expand(path);
          }
        }
        if (path.startsWith(this.prefix) && path.slice(this.prefix.length) !== '') {
          this.onReadyBrowse = path;
          return this.tree.fetch();
        }
      };

      TreeView.prototype.render = function() {
        var node, _i, _len, _ref;
        this.$el.empty();
        if (this.prefix === '') {
          this.$el.addClass('top');
        }
        _ref = this.tree.models;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          this.$el.append(node.get('nv').el);
        }
        return this;
      };

      TreeView.prototype.onClose = function() {
        return this.tree.off(null, null, this);
      };

      return TreeView;

    })(Backbone.View);
    return {
      TreeView: TreeView,
      Tree: Tree
    };
  });

}).call(this);
