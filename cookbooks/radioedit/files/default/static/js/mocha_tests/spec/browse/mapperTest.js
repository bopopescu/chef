// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var Backbone, DataTypesCollection, DefaultRow, Foobar, Mapper, Row, populateResponse, _ref;
    _ref = require('src/browse/mapper'), Mapper = _ref.Mapper, DataTypesCollection = _ref.DataTypesCollection;
    Backbone = require('backbone');
    populateResponse = require('util/ResponseHelper').populateResponse;
    Foobar = (function(_super) {

      __extends(Foobar, _super);

      function Foobar() {
        return Foobar.__super__.constructor.apply(this, arguments);
      }

      return Foobar;

    })(Backbone.View);
    Row = (function(_super) {

      __extends(Row, _super);

      function Row() {
        return Row.__super__.constructor.apply(this, arguments);
      }

      return Row;

    })(Backbone.View);
    DefaultRow = (function(_super) {

      __extends(DefaultRow, _super);

      function DefaultRow() {
        return DefaultRow.__super__.constructor.apply(this, arguments);
      }

      return DefaultRow;

    })(Backbone.View);
    describe('Mapper', function() {
      var collection, dataType, mapper, spyCallback;
      collection = null;
      dataType = 'baz';
      mapper = null;
      spyCallback = null;
      beforeEach(function() {
        var model;
        spyCallback = sinon.spy();
        model = new Backbone.Model({
          id: dataType
        });
        collection = new DataTypesCollection([model]);
        sinon.stub(collection, 'populate').returns(new $.Deferred().resolve().promise());
        mapper = new Mapper(collection);
        mapper["default"] = {
          thing: Foobar,
          row: DefaultRow
        };
        return mapper.register(mapper.ROW, dataType, Row);
      });
      it('should register a dataType to a name and class', function() {
        return mapper.dataTypes[dataType][mapper.ROW].should.equal(Row);
      });
      it('should call a callback with the class associated with the dataType and name', function() {
        mapper.get(mapper.ROW, dataType, spyCallback);
        return spyCallback.should.have.been.calledWithExactly(Row);
      });
      it('should return the instance from register', function() {
        return mapper.register('thing', dataType, function() {}).should.equal(mapper);
      });
      it('should reference the collection for a matching data type.', function() {
        mapper.get(mapper.ROW, dataType, spyCallback);
        return collection.populate.should.have.been.calledOnce;
      });
      it('should return the class in default if the data type is not in the collection', function() {
        mapper.get(mapper.ROW, 'foo', spyCallback);
        return spyCallback.should.have.been.calledWithExactly(DefaultRow);
      });
      it('should throw an error if the name is not in the dataTypes or the default', function() {
        var test;
        test = function() {
          return mapper.get('foo', dataType, spyCallback);
        };
        return test.should["throw"]('foo is not a valid name.');
      });
      it('should return the class in default if there are no matching names in the data type', function() {
        mapper.get('thing', dataType, spyCallback);
        return spyCallback.should.have.been.calledWithExactly(Foobar);
      });
      it('should work with a promise', function() {
        mapper.get(mapper.ROW, dataType).done(spyCallback);
        return spyCallback.should.have.been.calledWithExactly(Row);
      });
      return afterEach(function() {
        collection = null;
        mapper = null;
        return spyCallback = null;
      });
    });
    return describe('Data Types Collection', function() {
      var collection, emptyResponse, server, should;
      emptyResponse = populateResponse({
        datatypes: {}
      });
      server = null;
      collection = null;
      should = chai.should();
      beforeEach(function() {
        server = sinon.fakeServer.create();
        return collection = new DataTypesCollection();
      });
      it('should set the deferred property on a fetch', function() {
        should.not.exist(collection.deferred);
        collection.fetch();
        return collection.deferred.should.not.be["null"];
      });
      describe('Populate Callback', function() {
        var callbackSpy;
        callbackSpy = null;
        beforeEach(function() {
          return callbackSpy = sinon.spy();
        });
        it('should call the populate callback', function() {
          collection.populate({}, callbackSpy);
          server.respond(emptyResponse);
          return callbackSpy.should.have.been.calledOnce;
        });
        it('should call the populate callback with the deferred property', function() {
          sinon.spy(collection, 'fetch');
          collection.fetch();
          server.respond(emptyResponse);
          collection.fetch.should.have.been.calledOnce;
          collection.populate().done(callbackSpy);
          callbackSpy.should.have.been.calledOnce;
          collection.fetch.should.have.been.calledOnce;
          return collection.fetch.restore();
        });
        return it('should work with a promise', function() {
          collection.populate().done(callbackSpy);
          server.respond(emptyResponse);
          return callbackSpy.should.have.been.calledOnce;
        });
      });
      return afterEach(function() {
        server.restore();
        server = null;
        return collection = null;
      });
    });
  });

}).call(this);
