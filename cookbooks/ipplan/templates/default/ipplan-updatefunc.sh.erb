usage ()
{
    echo "Usage:"
    echo "$THIS_SCRIPT"
    echo
}

cleanup()
{
    # TODO: clean something: lock file?
    rm -f $WORKDIR/*.{xml,zone,fake}
    rm -f $STAGING/*.fake
    exit 0;
}
trap cleanup 1 2 3 9

failure_fatal()
{
    echo "$@"
    RETVAL=1
    exit $RETVAL
}

# TODO: i'm not getting $4 here.
failure_nonfatal()
{
    echo "$@"
}

preflight_check()
{
  CURRENTIP=$(/sbin/ip addr show dev eth0 | grep secondary | awk '{print $2}' | awk -F\/ '{print $1}')

  if [ ! $CURRENTIP == $HOSTAUTOGENIP ]; then
      echo "It appears you're not running this from the"
      echo "appropriate host. Do not run this on a host"
      echo "other than CFE ns_bindauto_stage, which is - ${HOSTAUTOGENIP}."
      echo "preflight_check: Exiting!"
      failure_fatal "wrong_host"
  fi

  # test all binaries?
  [ -x $XSLTPROC ] || failure_fatal "missing_command $XSLTPROC"
  [ -x $GIT ] || failure_fatal "missing_command $GIT"
  [ -x $RSYNC ] || failure_fatal "missing_command $RSYNC"
  [ -x $NC ] || failure_fatal "missing_command $NC"
  [ -x $SUDO ] || failure_fatal "missing_command $SUDO"
  [ -x $STAT ] || failure_fatal "missing_command $STAT"
  [ -x $NAMEDCHKZONE ] || failure_fatal "missing command $NAMEDCHKZONE"
  RETVAL=0
}

xsltforwardzone()
{
  ALL_FWD_ZONES=$(find "$WORKDIR" -name "zone_*.xml")
  for ZONE in $ALL_FWD_ZONES; do
    XMLFILE="$ZONE"
    ZONE=$(echo $XMLFILE | cut -f2 -d '_')
    [ "$DEBUG" = 2 ] && echo "DEBUG2: $XSLTPROC $SS_BIND9_FWD $XMLFILE > $WORKDIR/$ZONE.$FILETAG.zone"

    $XSLTPROC $SS_BIND9_FWD $XMLFILE > $WORKDIR/$ZONE.$FILETAG.zone
    RETVAL=$?
    if [ $RETVAL -ne 0 ]; then
      [ "$DEBUG" ] && echo "ERROR: xsltproc error in xsltforwardzone func"
      [ "$DEBUG" = 2 ] && XSLTPROCMSG=$($XSLTPROC $SS_BIND9_FWD $XMLFILE > $WORKDIR/$ZONE.$FILETAG.zone 2>&1)
      failure_fatal "xsltforwardzone_error"
    fi
    echo >> $WORKDIR/$ZONE.$FILETAG.zone
    echo >> $WORKDIR/$ZONE.$FILETAG.zone

# GMATZ - Right here I need to find the A records in $WORKDIR/$ZONE.$FILETAG.zone and create a CNAME
# for the record if the interface is the default gateway
# This may seem like a total hack, but bear with me . . .  I'm going to replace the whole thing one day
/usr/bin/env ruby <<-EOR

require 'chef/rest'
require 'chef/search/query'

# This $ will get expanded by shell
xfile = "$WORKDIR/$ZONE.$FILETAG.zone" 

# TODO Make path to knife.rb generic
begin
  Chef::Config.from_file('/home/' + ENV["LOGNAME"] + '/.chef/knife.rb')
rescue => e
  puts "Error configuring chef: #{e.message}"
  exit 1
end
 
#  Search returns an array of stuff.  Just need first element
vlan_by_host = {}

begin
  Chef::Search::Query.new.search('node', 'chef_environment:prod') do |n|
    # Some machines don't have a default interface defined
    next unless defined? n[:network][:default_interface]
    iface = n[:network][:default_interface]
    # We only want interfaces which have a 3-digit vlan extension
    next unless iface =~ /\.(\d{3})$/
    # backslash escape here so shell does not expand
    vlan = \$1
    hostname = n[:hostname]
    vlan_by_host[hostname] = vlan
  end
rescue Exception => e
  puts "Error getting info from chef DB: #{e.message}"
  exit 1
end

# Now check the entries of the xfile and see if there are any A records
# that have a vlan extension (e.g. -v200) that matches the vlan_by_host
# and create two CNAMEs replacing the VLAN with .prod and -prod
f_out = xfile + '.' + "$$"
file_out = File.open(f_out, "w")

File.open(xfile, "r") do |file_in|
  while line_in = file_in.gets
    # copying the line into the new file
    file_out.write(line_in)
    # Then writing out a CNAME if required
    # Looking for something ling "hostname-v200 IN A"
    puts "Just saw: #{line_in}"
    # Don't want these, i don't think
    next if line_in =~ /-vip-/
    # Watch the parens here . . .  it goes vip_hostname, real_hostname, vlan
    next unless line_in =~ /\A((.*)-v(\d{3}))\s+IN\s+A/
    puts "Just saw: #{line_in}"
    # We just captured the hostname & VLAN Id, if it exists (Sorry, Mark)
    # Again, backslash escaping to shell does not expand
    # real_hostname is the hostname of the machine, rather than the hostname-v### name
    vip_hostname = \$1; real_hostname = \$2; vlan = \$3 ;
    # puts "#{real_hostname} : #{vlan} : #{vip_hostname}"
    new_cname_rec = real_hostname + "-prod IN CNAME " + vip_hostname
    # Trying to avoid dupes.  I bet there's a better - ruby - way to do this . . .
    next if `grep -w "#{new_cname_rec}" xfile`
    if defined? vlan_by_host[real_hostname] and vlan_by_host[real_hostname] == vlan
        #file_out.write(real_hostname + ".prod IN CNAME " + vip_hostname + "\n")
        file_out.write(new_cname_rec + "\n")
    end
  end
end

file_out.close
# I believe I don't need to close the read files, that the end of the block closes it

EOR

    if [ -e $STAGING/$ZONE.$FILETAG.zone ]; then
      PATCHF="/var/tmp/xsltforwardzone-patch.$$"
      [ "$DEBUG" = 2 ] && echo "DEBUG2: $DIFF -u $STAGING/$ZONE.$FILETAG.zone $WORKDIR/$ZONE.$FILETAG.zone > $PATCHF 2>/dev/null"
      $DIFF -u $STAGING/$ZONE.$FILETAG.zone $WORKDIR/$ZONE.$FILETAG.zone > $PATCHF 2>/dev/null
      RETVAL=$?
      if [ $RETVAL = 2 ]; then  # diff had errors
        [ "$DEBUG" -gt 0 ] && echo "ERROR: diff error in xsltforwardzone func"
        [ "$DEBUG" = 2 ] && DIFFMSG=$($DIFF -u $STAGING/$ZONE.$FILETAG.zone $WORKDIR/$ZONE.$FILETAG.zone 2>&1)
        failure_fatal "xsltforwardzone_error"
      elif [ $RETVAL = 1 ]; then  # diff found differences
        [ "$DEBUG" = 2 ] && echo "DEBUG2: $PATCH -s $STAGING/$ZONE.$FILETAG.zone $PATCHF 2>/dev/null"
        $PATCH -s $STAGING/$ZONE.$FILETAG.zone $PATCHF 2>/dev/null
        RETVAL=$?
        if [ $RETVAL -ne 0 ]; then
          [ "$DEBUG" -gt 0 ] && echo "ERROR: patch error in xsltforwardzone func"
          [ "$DEBUG" = 2 ] && PATCHMSG=$($PATCH -s $STAGING/$ZONE.$FILETAG.zone $PATCHF 2>&1 )
          failure_fatal "xsltforwardzone_error"
        fi
      fi
      rm -f $PATCHF
    else
      cp -f $WORKDIR/$ZONE.$FILETAG.zone $STAGING/$ZONE.$FILETAG.zone
    fi

    cp -f $STAGING/$ZONE.$FILETAG.zone $STAGING/$ZONE.$FILETAG.zone.fake
    # remember, bind complains if zone file doesn't end with a newline
  	echo >> $STAGING/$ZONE.$FILETAG.zone

      # copy new zone to $ROOTDIR (/var/named/chroot-stage/var/named/internal)
  	[ $DEBUG = 2 ] && echo "DEBUG2: cp -f $STAGING/$ZONE.$FILETAG.zone $ROOTDIR/$ZONE.$FILETAG.zone"
  	cp -f $STAGING/$ZONE.$FILETAG.zone $ROOTDIR/$ZONE.$FILETAG.zone

  	echo >> $WORKDIR/$ZONE.$FILETAG.zone.fake
  	[ $DEBUG = 2 ] && echo "DEBUG2: cp -f $STAGING/$ZONE.$FILETAG.zone.fake $ROOTDIR/$ZONE.$FILETAG.zone.fake"
  	cp -f $STAGING/$ZONE.$FILETAG.zone.fake $ROOTDIR/$ZONE.$FILETAG.zone.fake
  done
  
  RETVAL=0
}

xsltreversezone()
{
    ALL_REV_ZONES=$(find $WORKDIR -name 'revzone_*.xml')
    echo "ALL_REV_ZONES=" $ALL_REV_ZONES
    for ZONE in $ALL_REV_ZONES; do
	XMLFILE=$ZONE
	ZONE=$(echo $XMLFILE | cut -f2 -d '_')
	[ $DEBUG = 2 ] && echo "DEBUG2: $XSLTPROC $SS_BIND9_REV $XMLFILE > $WORKDIR/$ZONE.$FILETAG.zone"
	$XSLTPROC $SS_BIND9_REV $XMLFILE > $WORKDIR/$ZONE.$FILETAG.zone 2>/dev/null
	RETVAL=$?
	if [ $RETVAL -ne 0 ]; then
            [ "$DEBUG" -gt 0 ] && echo "ERROR: xsltproc error in xsltreversezone func"
            [ "$DEBUG" = 2 ] && XSLTPROCMSG=$($XSLTPROC $SS_BIND9_REV $XMLFILE > $WORKDIR/$ZONE.$FILETAG.zone 2>&1)
            failure_fatal "xsltreversezone_error"
	fi

        # bind complains if zone file doesn't end with a newline
	echo >> $WORKDIR/$ZONE.$FILETAG.zone

	if [ -e $STAGING/$ZONE.$FILETAG.zone ]; then
            PATCHF="/var/tmp/xsltreversezone-patch.$$"
            [ "$DEBUG" = 2 ] && echo "DEBUG2: $DIFF -u $STAGING/$ZONE.$FILETAG.zone $WORKDIR/$ZONE.$FILETAG.zone > $PATCHF 2>/dev/null"
            $DIFF -u $STAGING/$ZONE.$FILETAG.zone $WORKDIR/$ZONE.$FILETAG.zone > $PATCHF 2>/dev/null
            RETVAL=$?
            if [ $RETVAL = 2 ]; then  # diff had errors
		[ "$DEBUG" -gt 0 ] && echo "ERROR: diff error in xsltreversezone func"
		[ "$DEBUG" = 2 ] && DIFFMSG=$($DIFF -u $STAGING/$ZONE.$FILETAG.zone $WORKDIR/$ZONE.$FILETAG.zone 2>&1 )
		failure_fatal "xsltreversezone_error"
            elif [ $RETVAL = 1 ]; then  # diff found differences
		[ $DEBUG = 2 ] && echo "DEBUG2: $PATCH -s $STAGING/$ZONE.$FILETAG.zone $PATCHF 2>/dev/null"
		$PATCH -s $STAGING/$ZONE.$FILETAG.zone $PATCHF 2>/dev/null
		RETVAL=$?
		if [ $RETVAL -ne 0 ]; then
                    [ "$DEBUG" -gt 0 ] && echo "ERROR: patch error in xsltreversezone func"
                    [ "$DEBUG" = 2 ] && PATCHMSG=$($PATCH -s $STAGING/$ZONE.$FILETAG.zone $PATCHF 2>&1 )
                    failure_fatal "xsltreversezone_error"
		fi
            fi
            rm -f $PATCHF
	else
            cp -f $WORKDIR/$ZONE.$FILETAG.zone $STAGING/$ZONE.$FILETAG.zone
	fi
    # copy new zone to $ROOTDIR (/var/named/chroot-stage/var/named/internal)
	[ $DEBUG = 2 ] && echo "DEBUG2: cp -f $STAGING/$ZONE.$FILETAG.zone $ROOTDIR/$ZONE.$FILETAG.zone"
	cp -f $STAGING/$ZONE.$FILETAG.zone $ROOTDIR/$ZONE.$FILETAG.zone
    done
    RETVAL=0
}

bindcheckfwd()
{
    # if named-checkzone succeeds against the "fake" file, move into git repo
    [ $DEBUG = 2 ] && echo "DEBUG2: $NAMEDCHKZONE -q $ZONE $ROOTDIR/$ZONE.$FILETAG.zone.fake"
    $NAMEDCHKZONE -q $ZONE $ROOTDIR/$ZONE.$FILETAG.zone.fake
    RETVAL=$?
    if [ $RETVAL -ne 0 ]; then
        [ "$DEBUG" ] && echo "ERROR: named-checkzone error in bindcheckfwd func"
        [ $DEBUG = 2 ] && NAMEDCHKZONEMSG=$($NAMEDCHKZONE -d $ZONE $ROOTDIR/$ZONE.$FILETAG.zone.fake 2>&1 )
        touch $FWDERRTOUCHFILE
        failure_fatal "bindcheckfwd_error: $NAMEDCHKZONEMSG"
    fi
    rm -f $FWDERRTOUCHFILE
    RETVAL=0
}
bindcheckrev()
{
    # if named-checkzone succeeds, git commit it.
    [ $DEBUG = 2 ] && echo "DEBUG2: $NAMEDCHKZONE -q $ZONE $ROOTDIR/$ZONE.$FILETAG.zone"
    $NAMEDCHKZONE -q $ZONE $ROOTDIR/$ZONE.$FILETAG.zone
    RETVAL=$?
    if [ $RETVAL -ne 0 ]; then
        [ "$DEBUG" ] && echo "ERROR: named-checkzone error in bindcheckrev func"
        [ $DEBUG = 2 ] && NAMEDCHKZONEMSG=$($NAMEDCHKZONE -d $ZONE $ROOTDIR/$ZONE.$FILETAG.zone 2>&1 )
        touch $REVERRTOUCHFILE
        failure_fatal "bindcheckrev_error"
    fi
    rm -f $REVERRTOUCHFILE
    RETVAL=0
}

commit_changes()
{
    if [ -e $FWDERRTOUCHFILE ] || [ -e $REVERRTOUCHFILE ]; then
        failure_fatal "detected an error with last export. aborting commit process."
    fi

    mkdir $WORKDIR/$WORKDIRGIT
    cd $WORKDIR/$WORKDIRGIT
    git clone <%= @git_repo %> .

    WORKDIR_ABS_PATH="$WORKDIR/$WORKDIRGIT/named/internal"
    [ "$DEBUG" -gt 0 ] && echo "DEBUG: WORKDIR_GIT:\t $WORKDIR_ABS_PATH"
    mkdir -p $WORKDIR_ABS_PATH
    # pull our new files in
    [ $DEBUG = 2 ] && echo "DEBUG2: cp -f $STAGING/*.zone $WORKDIR_ABS_PATH"
    cp -f $STAGING/*.zone $WORKDIR_ABS_PATH
    [ $DEBUG = 2 ] && git status 2>&1
    [ $DEBUG = 2 ] && git diff 2>&1

    # add all files
    [ $DEBUG = 2 ] && echo "DEBUG2: $PWD; git add -A"
    git add -A
    # checkin
    [ $DEBUG = 2 ] && echo "DEBUG2: $PWD; git commit -a -m '$COMMITTAG'"
    git commit -a -m "$COMMITTAG" >/dev/null 2>&1

    git pull -q --rebase >/dev/null
    git push 2>&1 > /dev/null

    [ "$DEBUG" ] && git diff

    # Grab the revision now, we'll need it later
    GITREV=$(git rev-parse HEAD);
    if [ "${GITREV}x" == "x" ]; then
        failure_fatal "gitrevision_check"
    fi

}
